* Major points from the reviews

1. Comparison with previous work, e.g., "Modelisation of Timed Automata in Coq" by Christine Paulin-Mohring, Coq's code extraction capabilities, various works on implementing TA in Coq.
   a. A comment on Verdi that its limitation in addressing timing is not fundamental and can be overcome. How are we address that comment? We need to emphasize more / make a better case why Verdi is not suitable.

2. The focus is too narrow on communication protocols in embedded systems like SEGA.

3. Lacks technical details and / or examples of translating from formal models to specs, ghost code, etc.


* Plan

** Motivation and Goals

I think the motivation should be improved to better explain the scope and the approach taken in our proposal.

- Make it super clear that our work targets general embedded systems. We select the communication protocol problem & SEGA case study as it's a difficult problem and representative of problems in embedded systems (timing and coordination between different subsystems).  Somehow our current writing causes the impression that our work only focuses on communication protocol in SEGA.

- Make it clear that we target existing code, not auto-generating (provenly correct) code from formal models:
  - Because existing code in existing systems are abundant, we don't want them to be rewritten just to utitlize code generation tools.
  - Because those auto code generation tools are not sufficient: real embedded systems usually require peripheral code (library calls, I/O interface with physical world,...) not generated by these tools and can affect the final systems.  We need to be careful here because there are tools (such as Matlab/Simulink embedded code generation tools) that can generate full system code; however they are not formally verified and we have to trust the vendor.

- Make it very clear that we target users who are embedded system engineers, who don't know and don't want to learn Coq.  Therefore, our approach aims to create automated tools that don't require any or deep knowledge of Coq / interactive provers.  That's different from many other tools / approaches.  Our NFM 2019 (http://dx.doi.org/10.1007/978-3-030-20652-9_6) paper shows that it is possible to get rid of Coq.

- We need to find different ways to express our goals so we can repeat that several times in the proposal.


** Related work

I'm not very familiar with the aforementioned related work (in Coq, Ocaml, Verdi), but we should clearly distinguish our approach with those.

- Basically all Coq related work is non relevant: we don't want IoT engineers learn Coq to design systems!  However, there was one caveat in using Frama-C: sometimes Coq was required to write some proofs when automated provers fail.  Our NFM 2019 (http://dx.doi.org/10.1007/978-3-030-20652-9_6) paper shows that it is possible to get rid of Coq.


** Technical details

1. As I understand, we don't aim to verify that the code satisfies certain temporal logic specifications (that's done by the formal modeling and verification tools like UPPAAL).  Rather, we aim to verify that the code "faithfully" implements the timed automata.  How do we define that explicitly?  How are the Coq annotations (pre-conditions, post-conditions, etc.) and ghost code able to verify that?  What types of new annotations will be needed?  I think we should provide a bit more details.

2. What kinds of timed automata will we consider?  The full TA specs of UPPAAL (which can be quite complex with local variables, user-defined functions, broadcasting, etc.) or a simpler version?  Or will we develop our approach on increasingly complex TA specs, starting from the basic (Alur's and Dill's TA) to the UPPAAL TA?

3. I don't know about previous related work in Coq, but ours targets real embedded systems, so non-determinism will be an issue, especially related to I/O with physical world.  We briefly wrote about the timing aspect in the context of WCET and parallel C programs.  We should also directly address the temporal non-determinism of the outside world:
   - worst-case analysis
   - model world as timed automata interacting with the software system?
   - new annotations to specify temporal non-determinism of world
   - generate parallel ghost code to represent world?

4. We need more discussion on some principles of generating annotations and ghost code (related to point 1 above).  It's best to present a simple example.  I'd suggest we take a very simple communication protocol example implemented in UPPAAL / TA and work out the C code, annotations, ghost code.  I think this would immensely improve our proposal.

5. Risk analysis: we should write about the risks involved (our proposed approach doesn't work then what are the alternatives?)


** Applications / Case study

Should we have other applications in addition to SEGA?

- Some years ago I read a paper on control communication protocol for high-speed trains formally verified by UPPAAL.  A potential simulation-based case study?

- Manufacturing automation involves a lot of precise timed sequences.  Potentially a good non-communication-related case study, to illustrate that our work is not limited to communication protocols.  Possible issues: simulation only (we can have a Capstone team build a desktop scale manufacturing testbed, easy and fun); most manufacturing automation systems are not written in C family but use PLCs (Programmable Logic Controllers) and specialized languages (e.g., SFC - Sequential Function Charts - for finite state machines).

- Robot task coordination: I have a research drone system in my lab.  We can consider code to control a drone, or multiple drones, to carry out tasks that are planned at high level as timed automata.  This application could be real experiments, but it will require extra human resource (student effort to work on the drone experiments) and can be quite sophisticated.


** Others

- Should add Frederic's and Truong's prior NSF support: none.
