While \framac{} provides powerful tools for static detection of program faults and generation of runtime checks for properties that cannot be discharged by formal proof or sound static analysis, it provides only limited, and difficult-to-scale, ability to generate program inputs to exercise runtime checks, limited to one tool, PathCrawler~\cite{WilliamsMMR05EDCC}, that aims to produce a unit test for a single function, using concolic testing (that is, dynamic symbolic execution~\cite{GodefroidKS05}).  In cases where concolic execution fails to scale, PathCrawler will fail to produce useful results.  Furthermore, PathCrawler is tuned to the problem of testing a single function, not producing more complex scenario-based tests of, e.g., an set of API calls to a library, or even a set of multiple functions that must coordinate access to a data structure.  Finally, PathCrawler is not an open source, extensible system, but a proprietary system that may be costly for non-academic users to acquire and use.

The limitation of dynamic analysis tools to PathCrawler is a major weakness of \framac from the perspective of a user.  Scalability of symbolic-execution-based test generation methods is extremely difficult to predict, and producing complete and exhaustive preconditions that allow a function to be tested entirely in isolation is often either too time-consuming or essentially impossible, because the actual environment is only represented by the set of states reachable using a set of coordinating functions or a library.  These problems are pressing, for several reasons.  First, full formal proof of correctness is, at present, impractical for most realistic systems.  The actual work of fault detection and validation of software still relies, fundamentally, on effective testing.  Moreover, modeling and even static approaches often must rest on a basis of numerous un-examined assumptions about the behavior of hardware systems and low-level system behavior (e.g., what operating system calls actually return).  Only actual concrete inputs, tests, can be executed in a completely realistic environment, including real hardware.  Furthermore, only tests can satisfy regulatory requirements on, e.g., code coverage, and guarantee that faults detected will not be spurious, resulting from imprecise abstraction or weak assumptions.  In other words, testing (that is, dynamic analysis including generation of inputs) is both able to detect faults that escape modeling and proof, and the only method guaranteed to produce real faults that actually exist in the system as implemented and executed on top of a real hardware and software substrate, an especially critical concern in embedded and cyberphysical domains.

DeepState~\cite{DeepState} is a dynamic analysis tool that aims to provide a single, usable, flexible front-end to a wide variety of back-end systems for test-case generation.  Most developers do not know how to use symbolic execution tools; developers seldom even know how to use less challenging tools such as greybox fuzzers, even relatively push-button ones such as AFL \cite{aflfuzz}.  Even those developers whose primary code focus is critical security infrastructure such as OpenSSL are often not users, much less expert users, of such tools.  Furthermore, different tools find different faults, have different scalability limitations, and even have different show-stopping bugs that prevent them from being applied to specific testing problems.  DeepState aims to address this problem in two ways.

%Already written a few lines above:
%Software developers and embedded-systems engineers seldom know how to use symbolic execution tools or greybox fuzzers.  
Developers \emph{do}, however, often know how to use unit testing frameworks, such as JUnit~\cite{JUnit} or Google Test~\cite{GoogleTest}. DeepState makes it possible to write parameterized unit tests~\cite{ParamUnit} in a GoogleTest-like framework, and automatically produce tests using angr~\cite{angr1,angr2,angr3}, Manticore~\cite{Manticore}, American Fuzzy Lop~\cite{aflfuzz} (or other file-based fuzzers), or libFuzzer~\cite{libFuzzer}.  DeepState also targets the same space as property-based testing tools such as QuickCheck \cite{ClaessenH00}, ScalaCheck \cite{ScalaCheckDoc}, Hypothesis \cite{Hypothesis}, and TSTL \cite{NFM15,tstlsttt}, but DeepState's test harnesses look like C/C++ unit tests. The major difference from previous tools is that DeepState aims to provide a front-end that can make use of a growing variety of back-end methods for test generation, including (already) multiple binary analysis engines and non-symbolic fuzzers.  Developers who write tests using DeepState can expect that DeepState will let them, without rewriting their tests, make use of new symbolic execution or fuzzing advances.  The harness/test definition remains the same, but the method(s) used to generate tests may change over time.  In contrast, most property-based tools only provide random testing, and symbolic execution based approaches such as Pex \cite{Pex,UnitMeister} or KLEE \cite{KLEE}, while similar on the surface in some ways, always have a single back-end for test generation.  Even a system such as TSTL, which aims to provide a common interface \cite{WODACommon} to different testing methods assumes that all of those methods will be written using the TSTL API and (concrete) notion of state.

In effect, DeepState targets the same space (providing the technology and translation between different semantics neccessary to use different verification/bug-detection technologies) as this proposal, but narrowed to the domain of generating test inputs.  Moreover, DeepState goes beyond other parameterized unit testing tools by providing an interface that extends the typical, e.g., GoogleTest interface with constructs making it easy to generate tests for sets of functions, or entire libraries.  DeepState has already been used to test (and find bugs in) a user-mode ext3-like file system developed at the University of Toronto~\cite{testfs,testfsrepo} --- not to test each individual function, but to test the combination of all file-system operations, with the environment for each function defined as the set of states reachable by calling any of the file-system modifying functions.  DeepState additionally provides ``smart'' test case reduction based on the approach taken by the Hypothesis tool \cite{Hypothesis}, using its knowledge of, e.g., related bytes in an input, to efficiently construct easy-to-understand test cases from the complex inputs often generated by fuzzers.  Such reduction has also been shown to be useful in improving the performance of seeded symbolic testing \cite{issta14}.
DeepState is being considered as a basis for automatic testing for components in NASA's open source flight software framework FPrime~\cite{fprime,fprimerepo}.  DeepState is a fully open source system \cite{deepstaterepo}, supported by Trail of Bits (a New York based security analysis company), and is being considered as a future extension to the core GoogleTest framework.