While \framac{} provides powerful tools for static detection of program faults and generation of runtime checks for properties that cannot be discharged by formal proof or sound static analysis, it provides only limited, and difficult-to-scale, ability to generate program inputs to exercise runtime checks, limited to one tool, PathCrawler~\cite{WilliamsMMR05EDCC}, that aims to produce a unit test for a single function, using concolic testing (dynamic symbolic execution~\cite{GodefroidKS05}).  In cases where this fails to scale, PathCrawler will fail.  Furthermore, PathCrawler is tuned to the problem of testing a single function, not producing more complex scenario-based tests of a set of functions that must coordinate state changes.  Finally, PathCrawler is not an open source, extensible system, may be costly to acquire and use, and is arguably impossible to extend.

The limitation of dynamic analysis tools to PathCrawler is a major weakness of \framac from the perspective of a user.  Scalability of symbolic-execution-based test generation methods is extremely difficult to predict, and producing complete and exhaustive preconditions that allow a function to be tested entirely in isolation is often either too time-consuming or essentially impossible, because the actual environment is only represented by the set of states reachable using a set of coordinating functions or a library.  These problems are pressing, for several reasons.  First, full formal proof of correctness is, at present, impractical for most realistic systems.  The actual work of fault detection and validation of software still relies, fundamentally, on effective testing.  Moreover, modeling and even static approaches often must rest on a basis of numerous un-examined assumptions about the behavior of hardware systems and low-level system behavior (e.g., what operating system calls actually return).  Only actual concrete inputs---tests---can be executed in a completely realistic environment, including real hardware.  Only tests can satisfy regulatory requirements on code coverage such as those imposed on civilian avionics by DO-178B and its successors~\cite{MCDC}.  Furthermore, only testing can prove faults are not spurious, the result of imprecise abstraction or weak assumptions.
In sum, dynamic analysis can detect otherwise invisible faults, and confirm the reality of statically detected faults.

%DeepState~\cite{DeepState} is a dynamic analysis tool that aims to provide a single, usable, flexible front-end to a wide variety of back-end systems for test generation.
Most developers do not know how to use symbolic execution tools; developers seldom even know how to use less challenging tools such as gray-box fuzzers, even relatively push-button ones such as AFL~\cite{aflfuzz}.  Even those developers whose primary focus is critical security infrastructure such as OpenSSL are often not users, much less expert users, of such tools.  Furthermore, different tools find different faults, have different scalability limitations, and even have different show-stopping bugs that prevent them from being applied to specific testing problems.  DeepState~\cite{DeepState} addresses these problems.  First, developers \emph{do}, usually, know how to use unit testing frameworks, such as JUnit~\cite{JUnit} or Google Test~\cite{GoogleTest}. DeepState makes it possible to write parameterized unit tests~\cite{ParamUnit} in a GoogleTest-like framework, and automatically produce tests using symbolic execution tools~\cite{angr1,angr2,angr3,Manticore}, or fuzzers like AFL~\cite{aflfuzz} or libFuzzer~\cite{libFuzzer}.  DeepState targets the same space as property-based testing tools such as QuickCheck~\cite{ClaessenH00}, ScalaCheck~\cite{ScalaCheckDoc}, Hypothesis~\cite{Hypothesis}, and TSTL~\cite{NFM15,tstlsttt}, but with harnesses that look like C/C++ unit tests. DeepState is the first tool to provide a front-end that can make use of a growing variety of back-ends for test generation.  Developers who write tests using DeepState can expect that DeepState will let them, without rewriting their tests, make use of new symbolic execution or fuzzing advances.  The harness/test definition remains the same, but the method(s) used to generate tests may change over time.  In contrast, most property-based tools only provide random testing, and symbolic execution based approaches such as Pex~\cite{Pex,UnitMeister} or KLEE~\cite{KLEE}, while similar on the surface in some ways, have a single back-end for test generation. DeepState's flexibility is evident: in the last few months, DeepState added support for the Eclipser~\cite{eclipser}, Angora~\cite{angora}, and Honggfuzz~\cite{Honggfuzz} fuzzers, as well as an ensemble~\cite{enfuzz} mode  supporting  the use  of multiple fuzzers at once~\cite{ensemble}.

%Even a system such as TSTL, which aims to provide a common interface \cite{WODACommon} to different testing methods assumes that all of those methods will be written using the TSTL API and (concrete) notion of state.

In effect, DeepState targets the same space (providing the technology and translation between different semantics necessary to use different verification/bug-detection technologies) as this proposal, but narrowed to the domain of generating test inputs.
%Moreover, DeepState goes beyond other parameterized unit testing tools by providing an interface that extends the typical GoogleTest interface with constructs making it easy to generate tests for APIs.
DeepState has already been used to test (and find bugs in) a user-mode ext3-like file system developed at the University of Toronto~\cite{testfs,testfsrepo}.
%DeepState provides ``smart'' state-of-the-art test case reduction~\cite{OneTest}, using its knowledge of test structure to efficiently construct easy-to-understand test cases from the complex inputs often generated by fuzzers.  Such reduction has been shown to be useful in improving the performance of seeded symbolic testing \cite{issta14}.
DeepState is being considered as a basis for automatic testing for components in NASA's open source flight software framework FPrime~\cite{fprime,fprimerepo}, and is a fully open source system~\cite{deepstaterepo}, supported by Trail of Bits (a New York based security analysis company, which uses DeepState in security audits).  DeepState is being considered as a future extension to the core GoogleTest framework.  Although only released in early 2018, DeepState is already one of the most popular property-based testing and fuzzing projects on GitHub, and has been used internally by major companies and in security audits by Trail of Bits.  There have even been informal discussions of integrating DeepState, once matured, into a future release of Google's GoogleTest platform, one of the most widely used unit testing frameworks in the world.