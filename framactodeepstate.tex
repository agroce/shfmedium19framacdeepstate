While \framac allows, ideally, for proof of correctness of annotated code, in many real-world instances it will be impossible to prove correctness, either because the proof is too hard to construct or because the code is not in fact correct.  While \framac provides some mechanisms for generating possible counterexamples to a proof, and limited test case generation, it is far from ideal in this setting.  A full workflow for verification of realistic systems, therefore, requires a first-class \emph{dynamic} analysis component.  Furthermore, such a component should not limit itself to a single method for generating test cases, as with tools such as KLEE \cite{KLEE}, Pex \cite{Pex}, or the test generation tools provided by \framac \cite{PathCrawler}.  Predicting which test generation methods will discover a fault in code, or simply scale to provide effective exploration of code paths, is notoriously difficult.  Furthermore, most tools are research prototypes and have known bugs that prevent application to some subset of programs.  We therefore aim to provide a \emph{flexible} dynamic front-end that provides a one-stop solution to the problem of dynamic analysis, either to provide confidence in code that cannot be proven correct, or to discover a counterexample showing that the code is not correct.  \deepstate \cite{DeepState} provides such a front-end.

The research challenge here is to translate \acsl-annotated code for use in \framac into a \deepstate test harness.  This problem can further be broken down into three key-subproblems:

\begin{enumerate}[labelsep=3pt,leftmargin=12pt]
\item The \emph{specification} of correctness must be translated into an executable specification for use by DeepState.  To some extent, the existence of the \eacsl executable subset of \acsl and libraries for runtime checking of properties satisfies this condition.  DeepState can support any C/C++ executable method of checking for correctness.  However, because DeepState provides more back-ends, some executable specifications may need to be modified to be efficiently handled when the DeepState back-end is a symbolic execution tool.  Additionally, it is important to instrument the executable code that support specifications in order to make the coverage of the specification itself visible to fuzzer back-ends, such as libFuzzer.  Moreover, DeepState's nature as a test generation tool means that it support constructs, such as ForAll, Minimum, and Maximum, that are not normally available in executable specifications.  Tailoring \eacsl usage for DeepState therefore requires a custom effort, including extending the semantics of ``executable'' specifications and optimizing the implementation for symbolic execution and fuzzing.  Finally, because our domain critically involves timing, we need to implement DeepState handling (and \eacsl representations for) deadlines, and specification of function-level deadlines including arbitrary, specified, ``runtimes'' for code that operates via simulation rather than real hardware, including nondeterministic expression of the timing constraints on calls, and introducing ghost branches that make timing impacts more visible to coverage-driven fuzzers.
\item The \emph{assumptions} that control which tests are considered valid must be translated in the same way; normally, \eacsl simply translates these into further assertions (as pre-conditions to check at runtime), but in DeepState, we need to distinguish between {\tt ASSUME} constructs where failure indicates an invalid test and {\tt ASSERT} constructs where failure indicates a failing test.  Additionally, the same optimizations and visibility improvements as for the specification must be provided.
\item Finally, the inputs to a function must be translated into code controlling the input values that DeepState must generate in a test, including ranges and types.  When input types are simple, this process is straightforward; however, when functions take, e.g., arbitrarily sized arrays or linked lists, or other complex structures, this becomes a problem of constructing a test harness that (1) makes fuzzing and symbolic execution scalable but (2) allows large enough structures to expose subtle bugs.  Moreover, because DeepState supports strategies for input generation, such as forking concrete states for values too complex for symbolic execution using the {\tt Pump} construct, the translation must determine when such strategies are appropriate.
\end{enumerate}

Additionally, in some cases, checking a single function may not be an effective way to detect faults; only a sequence of API calls can expose a problem in a system (e.g., that a function produce a state that causes another function to violate an invariant).  \acsl annotations provide enough information for a fully-automated translation to a harness enabling dynamic analysis in the case of proving properties of a single function, but this is no longer true for groups of functions.  Moreover, even in cases where the violation of a specification can, in theory, be discovered without calling multiple functions, the state space described by the precondition for a function may be too large to explore with a fuzzer or symbolic execution tool.  In such cases, exploring the space described by valid calls of other functions has two benefits:  first, the space described by a sequence of calls may be much smaller, and easier to explore, than the full set of possible input values to a function.  Second, errors in this portion of the input space are more clearly realistic scenarios.  Even if a precondition is not sufficiently restrictive to guarantee correct behavior, if the ``bad'' inputs are never, in practice, generated by the functions that modify system state, the fault may never appear in practice.  In cases where constructing a sufficiently exact precondition is difficult for engineers, such ``in-use'' verification may be the only avenue to system assurance; proof is impossible without a restrictive enough precondition, and dynamic methods may scale very poorly to, e.g., a large unstructured byte buffer such as a hash table.

In principle, of course, users can write a new function (a kind of ``ghost function'' not really executed --- in practice, a test harness) expressing the desired mix of API calls that preserve an invariant; however, this is a serious burden on a user, and users are likely to make errors in this task \cite{CFV08,AMAI,scriptstospecs,groce2015verified,groce2018verified}; we instead propose to let users annotate (in an extension of \acsl) sets of functions to be tested as an API-call-sequence group.  E.g., annotating a set of file system functions ({\tt mkdir}, {\tt rmdir}, {\tt readdir}, etc.) as such a group could allow the automatic generation of a DeepState harness that checks for cases where a sequence of valid function calls can violate a precondition or cause a fault despite preconditions being satisfied.

